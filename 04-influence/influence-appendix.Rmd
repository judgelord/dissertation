---
# rmarkdown::render("04-influence/influence-appendix.Rmd")
title: "Policy Influence: Do Public Pressure Campaigns Influence Bureaucratic Policymaking?"
subtitle: "Appendix and Replication Code" 
author: "Devin Judge-Lord"
bibliography: '`r here::here("assets/dissertation.bib")`'
biblio-style: '`r here::here("assets/apsr.bst")`'
link-citations: yes
citecolor: black
editor_options: 
  chunk_output_type: console
output:
    bookdown::html_document2:
      highlight: zenburn
      toc: true
      toc_float: true
      code_folding: hide
      number_sections: false
---

```{r global.options, include=FALSE}
# load defaults
source(here::here("code", "setup.R"))

# overide defaults
knitr::opts_chunk$set(echo = TRUE, 
                      cache = FALSE,
                      fig.path='../figs/')
```



# Data

```{r child = "03-influence-data.Rmd"}
```


# Methods 

```{r child = "04-influence-methods.Rmd"}
```

---

# Results 

<!-- THIS IS WHERE THE RESULTS SECTION STARTS ---> 

```{r child = "05-influence-results.Rmd"}
```




# Extra Data

---

### Organization-level summary counts:

```{r}
# org comments by type 
comments_coded %>% filter(comment_type == "Org") %>%  
  mutate(org_type = str_remove(org_type, ";.*")) %>%
  count(org_type, sort =T) %>% 
  filter(n>1) %>% 
  kable3(caption = " ")

# org comments by sub-type
comments_coded %>% filter(comment_type == "Org") %>%  
  filter(str_detect(org_type, ";")) %>% 
  mutate(org_type_detailed = org_type) %>%
  count(org_type_detailed, sort =T) %>% 
  kable3(caption = " ")
```


---


#### Coaltion-level summary counts:

Coalition lobbying success and size:

```{r hist-coalitions-simple, out.width="32%", fig.height=2, fig.width=2, show = "hold"}
ggplot(coalitions_coded, aes(x = coalition_success)) + geom_histogram()+ 
  labs(x = "Coalition Success")

ggplot(coalitions_coded, aes(x = coalition_size)) + geom_histogram()+ labs(x = "Coalition size")

ggplot(coalitions_coded, aes(x = coalition_business_ %>% as.numeric())) + geom_histogram()+ labs(x = "Business Coalition")

#ggplot(coalitions_coded, aes( x= comment_length)) + geom_histogram()+ labs(x = "% (Comment length/proposed rule length)*100")

ggplot(coalitions_coded, aes( x= log(coalition_comments + 1))) + geom_histogram() + 
  labs(x = "Log(mass comments + 1)") 
```

Coalitions by type (public interest vs. private interest)

```{r hist-coalitions-type, out.width="49%", fig.height=3, fig.width=3, show = "hold"}
ggplot(coalitions_coded %>% filter(!is.na(coalition_type)), 
       aes(x = coalition_type)) + 
  geom_histogram(stat = "count")+ 
  labs(x = "Coalition Type",
       title = "Number of Observations\nby Coalition Type and Size\n(number of organizations)") +
  facet_wrap("Coalition_size")

ggplot(coalitions_coded %>% filter(!is.na(coalition_type)), aes(x = coalition_type)) + 
  geom_histogram(stat = "count")+ 
  labs(x = "Coalition Type",
       title = "Number of Observations\nby Coalition Type") +
  facet_wrap("Coalition_campaign")





```

---

```{r coded-coalition-congress, include=FALSE, fig.cap= "Lobbying Success by Number of Supportive Comments"}
#FIXME include when I have more MOCs
coalitions_coded %>% 
  drop_na(coalition_type, Coalition_Position) %>% 
  distinct(coalition_comment, coalition_type, coalition_size, coalition_congress, coalition_comments, agency, Coalition_Position) %>%
  ungroup() %>%
  ggplot() +
  aes(y = coalition_congress, x = log(coalition_comments), color = coalition_type) +
  geom_jitter(aes(size = coalition_size), alpha = .5) +
  geom_smooth(se = FALSE, method = "lm")+ 
  facet_grid(Coalition_Position ~ .) 
```


#### Number of supportive comments

```{r coded-coalition-success-comments, fig.cap= "Lobbying Success by Number of Supportive Comments", fig.width=5, fig.height=3}
coalitions_coded %>% 
  drop_na(coalition_type, Coalition_Position) %>% 
  distinct(coalition_comment, coalition_type, coalition_size, coalition_success, coalition_comments, agency, Coalition_Position) %>% 
  ungroup() %>%
  ggplot() +
  aes(y = coalition_success, x = log(coalition_comments), color = coalition_type) +
  geom_jitter(aes(size = coalition_size), alpha = .5) +
  geom_smooth(se = TRUE, method = "lm")

coalitions_coded %>% 
  drop_na(coalition_type, Coalition_Position) %>% 
  distinct(coalition_comment, coalition_type, coalition_size, coalition_success, coalition_comments, agency, Coalition_Position) %>% 
  ungroup() %>%
  ggplot() +
  aes(y = coalition_success, x = log(coalition_comments), color = coalition_type) +
  geom_jitter(aes(size = coalition_size), alpha = .5) +
  geom_smooth(se = FALSE, method = "lm")+ 
  facet_grid(Coalition_Position ~ .)

coalitions_coded %>% 
  drop_na(coalition_type, Coalition_Position) %>% 
  distinct(coalition_comment, coalition_type, coalition_size, coalition_success, coalition_comments, agency, president, Coalition_Position) %>% 
  ungroup() %>%
  ggplot() +
  aes(y = coalition_success, x = log(coalition_comments), color = coalition_type) +
  geom_jitter(aes(size = coalition_size), alpha = .5) +
  geom_smooth(se = FALSE, method = "lm") + 
  #facet_wrap("president")  + 
  facet_grid(Coalition_Position ~ president)
```

#### Coalition Size

(number of supportive organizations)

```{r coded-coalition-success-size, fig.cap= "Lobbying Success by Number of Supportive Comments", fig.width=5, fig.height=3}
coalitions_coded %>% 
  drop_na(coalition_type, Coalition_Position) %>% 
  distinct(coalition_comment, coalition_type, coalition_size, coalition_success, coalition_comments, agency, president, Coalition_Position) %>% 
  ungroup() %>%
  ggplot() +
  aes(y = coalition_success, x = coalition_size, color = coalition_type) +
  geom_jitter(aes(size = coalition_comments ), alpha = .5) +
  geom_smooth(se = FALSE, method = "lm") + 
  facet_grid(Coalition_Position ~ .)+ 
  scale_size_continuous(labels = comma)

coalitions_coded %>% 
  drop_na(coalition_type, Coalition_Position) %>% 
  distinct(coalition_comment, coalition_type, coalition_size, coalition_success, coalition_comments, agency, president, Coalition_Position) %>% 
  ungroup() %>%
  ggplot() +
  aes(y = coalition_success, x = coalition_size, color = coalition_type) +
  geom_jitter(aes(size = coalition_comments ), alpha = .5) +
  geom_smooth(se = FALSE, method = "lm") + 
  #facet_wrap("president") + 
  facet_grid(Coalition_Position ~ president)+ 
  scale_size_continuous(labels = comma)
```

#### The correlation between coalition size and the total number of comments

The total number of form-letter comments is highly correlated with the number of organizations in a coalition.

The total number of comments excludes organization comments. 

```{r coalition-size-mass-correlation, out.width="25%", fig.width=2.5, fig.height=2.5}
coalitions_coded %>% 
  ggplot() + 
  aes(x = coalition_size, y = comments) +
  geom_point() + 
  geom_smooth(method = "lm") + 
  labs(y = "Mass Comments",
       x = "Coalition Size\n(number of organizations)")

coalitions_coded %>% 
  mutate(comments = comments - coalition_size) %>%
  ggplot() + 
  aes(x = log(coalition_size), y = log(coalition_comments)) +
  geom_point() + 
  geom_smooth(method = "lm") + 
  labs(y = "Logged Mass Comments",
       x = "Logged Coalition Size\n(number of organizations)")
```

<!--
## Machine-coded Data

> IN PROGRESS

**Dependent variable:** *The percent change in policy text*...

**Explanatory variables:** The *total number of comments*...

-->


---

# Extra Methods



---



## DV = Comments from members of Congress


```{hypothesis oversight, echo = TRUE}
The scale of public engagement moderates elected officials' engagement in agency rulemaking
engagement.
```

> Preliminary finding: The size of the lobbying coalition (the number of organizations) is positively correlated with the number of members of Congress who engage. When we account for variation in coalition size, there is no evidence that the total number of comments is related to the number of comments from members of Congress.

The simplest model of the relationship between congressional attention and public attention is a model estimating the count of legislator letters as a function of features of the rulemaking, including the total number of public comments. The number of letters from members of congress would be a count process; this would be a Poisson or negative binomial regression.

In equation \@ref(eq:oversight1), $y_{j}$ is a count of the number of legislator comments on a proposed rule $j$, $\beta_1$ is the effect of a one-unit increase in the logged number of public comments on proposed rule $j$, and $\eta$ is a vector of coefficients on other factors ($X_{j}$) that may lead legislators to comment.

$$
y_{j}= \beta_0 + \beta_1 \text{log(Public comments)}_{j} + \eta X_{j} + \epsilon_{j} (\#eq:oversight1)
$$

---

Alternatively, if we want to control for legislator characteristics that may make them more or less likely to comment on a rule, we can make members of Congress the unit of analysis. The dependent variable is now whether or not a given legislator $i$ commented on the proposed rule $j$. The relationship between public engagement and legislator engagement can be modeled by Equation \@ref(eq:oversight2), where $Pr(Comment_{ij})$ is the probability that legislator $i$ comments on a proposed rule $j$, $\beta_1$ is the effect of a one-unit increase in the logged number of public comments on proposed rule $j$, and $\eta$ is a vector of coefficients on other factors ($X_{ij}$) that may affect whether a legislator engages.


$$logit(Pr(\text{Legislator comment}_{ij})) = \beta_0 + \beta_1 \text{log(Public comments)}_{ij} + \eta X_{ij} + \epsilon_{ij}
(\#eq:oversight2)$$



---

```{hypothesis beacon, echo = TRUE}
Public pressure campaigns attract
oversight from allies. The more comments supporting a position, the more
likely principals holding that position are to engage.
```

```{hypothesis warning, echo = TRUE}
Public pressure campaigns
reduce oversight from opponents. The more comments opposing a position,
the less likely principals holding that position are to engage.
```

The simplest model of the relationship between congressional attention and public support or opposition to a proposed rule would be to model the net count of legislator letters supporting and opposing the proposed as a function of features of the rulemaking, including the net number of public comments supporting and opposing. As the number of letters from members of congress would be a count process, this would be Poisson or negative binomial regression.

The model is the same as equation \@ref(eq:oversight1) except that $y_{j}$ is now the *net* number of legislator comments supporting a proposed rule $j$, and $\beta_1$ is now the effect of a one-unit increase in the logged *net* number of public comments supporting proposed rule $j$.

---

With a measure of the likely position on each rule (for example, if promulgated by a co-partisan administration), the individual legislator can be the unit of analysis. The probability that legislator $i$ will comment on rule $j$, given their position $p_{ij}$ on a proposed rule $j$ ($Pr(Comment_{ij}i|p_{ij})$), is modeled in equation \@ref(eq:oversight4). Hypothesis \@ref(hyp:beacon) implies that $\beta_1$ is positive and
Hypothesis \@ref(hyp:warning) implies that $\beta_2$ is negative.


$$logit(Pr(\text{Legislator Comment}_{ij}|p_{ij})) = \beta_0 + \beta_1 \text{Comments supporting } p_{ij} + \beta_2 \text{Comments opposing } p_{ij} + \eta X_{ij} + \epsilon_{ij}
(\#eq:oversight4)$$



# Extra Results

## President dummies

```{r mc-success-president}
# mc-success
coalitions_coded %<>% 
  mutate(party = ifelse(president == "Obama", "Democrat", "Republican"),
         president = as_factor(president) %>% relevel(ref = "Obama"))


# coalition success with agency and president FE
mc1 <- feols(coalition_success ~ 
          campaign_*coalition_type*president + 
          # campaign_*coalition_business_ +
          # log(comments + 1)*coalition_type
          # log(comments + 1)*coalition_business_ + 
          # comments * coalition_type + 
          # comments^2 * coalition_type +
          # comments^2 * coalition_business +
          coalition_ + log(coalition_size) + #  coalition_size^2 + 
          Coalition_Position + 
          # comment_length + 
          coalition_unopposed
          # Agency and president FE 
          | agency, #+ president, 
        data = coalitions_coded)

mc2 <- feols(coalition_success ~ 
          #campaign_*coalition_type + # m1
          campaign_*coalition_business_*president + # m2
          # log(comments + 1)*coalition_type # m3
          # log(comments + 1)*coalition_business_ + # m4
          # comments + comments^2 + coalition_type + #m5
          # comments + comments^2 + coalition_business_ + #m6
          coalition_ + log(coalition_size) + #  coalition_size^2 + 
          Coalition_Position + 
          # comment_length + 
          coalition_unopposed
          # Agency and president FE 
          | agency, #+ president, 
        data = coalitions_coded)

mc3 <- feols(coalition_success ~ 
          #campaign_*coalition_type + # m1
          # campaign_*coalition_business_ + # m2
          log(comments + 1)*coalition_type*president + # m3
          # log(comments + 1)*coalition_business_ + # m4
          # comments + comments^2 + coalition_type + #m5
          # comments + comments^2 + coalition_business_ + #m6
          coalition_ + log(coalition_size) + #  coalition_size^2 + 
          Coalition_Position + 
          # comment_length + 
          coalition_unopposed
          # Agency and president FE 
          | agency,# + president, 
        data = coalitions_coded)

mc4 <- feols(coalition_success ~ 
          #campaign_*coalition_type + # m1
          #campaign_*coalition_business_ + # m2
          # log(comments + 1)*coalition_type + # m3
          log(comments + 1)*coalition_business_*president + # m4
          # comments + comments^2 + coalition_type + #m5
          # comments + comments^2 + coalition_business_ + #m6
          coalition_ + log(coalition_size) + #  coalition_size^2 + 
          Coalition_Position + 
          # comment_length + 
          coalition_unopposed
          # Agency and president FE 
          | agency,# + president, 
        data = coalitions_coded)

mc5 <- feols(coalition_success ~ 
          # campaign_*coalition_type + # m1
          # campaign_*coalition_business_ + # m2
          # log(comments + 1)*coalition_type + # m3
          # log(comments + 1)*coalition_business_ + # m4
          comments + comments^2 + coalition_type*president + #m5
          # comments + comments^2 + coalition_business_ + #m6
          coalition_ + log(coalition_size) + #  coalition_size^2 + 
          Coalition_Position + 
          # comment_length + 
          coalition_unopposed
          # Agency and president FE 
          | agency , 
        data = coalitions_coded)

mc6 <- feols(coalition_success ~ 
          #campaign_*coalition_type + # m1
          # campaign_*coalition_business_ + # m2
          # log(comments + 1)*coalition_type + # m3
          # log(comments + 1)*coalition_business_ + # m4
          # comments + comments^2 + coalition_type + #m5
          comments + comments^2 + coalition_business_*president + #m6
          coalition_ + log(coalition_size) + #  coalition_size^2 + 
          Coalition_Position + 
          # comment_length + 
          coalition_unopposed
          # Agency and president FE 
          | agency, 
        data = coalitions_coded)

models_president <- list(mc1, mc2, mc3, mc4, mc5, mc6)


# paper table fixest
modelsummary::modelsummary( models_president, 
                            stars = TRUE, 
                            #coef_map =
                            coef_rename =  cm,
                            gof_omit = "R2 .*",
                          add_rows = rowsFE, 
                          notes = "") %>% 
  row_spec(row = 1, bold = T) #%>% kable2(file = "mc-success")
```


```{r model-success-plot, include=FALSE,  fig.width=6, fig.height=2, out.width = "100%", fig.cap= "OLS Model of Coalition Lobbying Sucess with Hand-coded Data"}
# My preferred model is model 3: 
# model-success-plot

mc1 %>%
  tidy(conf.int = TRUE) %>% 
  filter(term != "(Intercept)") %>% 
  left_join(cm2) %>% 
  ggplot() + 
  geom_hline(yintercept = 0, color = "grey") + 
  aes(x = Term, 
      y = estimate, 
      ymin = conf.low, 
      ymax = conf.high) + 
  geom_pointrange( )  + 
  coord_flip() +
  labs(y = "Lobbying Success", 
       x = "") 
```

### Mixed effects / hierarchical models

Because organizations are nested in coalitions, I estimate a hierarchical model grouping by coalition. 

```{r}
# mixed model with random effects for coalition
m_me = lmer(success ~ log(coalition_comments + 1)*coalition_type*president +
              Position + 
              log(coalition_size) + 
              (1|coalition), # random intercept for each coalition
               data = comments_coded %>% 
  filter(comment_type == "Org") %>% 
  distinct(org_name, docket_id, success, coalition_type, coalition_size, Position, coalition_comments, president, coalition, agency) %>% filter(president != "Bush"))


broom.mixed::tidy(m_me) %>% 
  mutate(term = ifelse(str_detect(term, "sd__.Int"), paste(group, term), term)) %>%  
  dwplot + geom_vline(xintercept=0,lty=2)

models <- list("Lobbying Success" = m_me)

modelsummary(models)
```

```{r, eval = FALSE}

tidy(m_me, conf.int = T)



tidy(m_me,effects="fixed")

fixef(m_me) #is the canonical way to extract coefficients from mixed models 

# you can get the full coefficient table with coef(summary(m)); if you have loaded lmerTest before fitting the model, or convert the model after fitting (and then loading lmerTest) via coef(summary(as(m,"merModLmerTest"))), then the coefficient table will include p-values. (The coefficient table is a matrix; you can extract the columns via e.g. ctab[,"Estimate"], ctab[,"Pr(>|t|)"], or convert the matrix to a data frame and use $-indexing.)

# get likelihood profile confidence intervals via 
confint(m_me) #; these may be computationally intensive. If you use confint(m, method="Wald") you'll get the standard +/- 1.96SE confidence intervals. (lme uses intervals(m) instead of confint().)

broom.mixed::tidy(m_me,effects="fixed")
# gives you a table with estimates, standard errors, etc.
# tidy(as(m,"merModLmerTest"), effects="fixed") (or fitting with lmerTest in the first place) includes p-values
# adding conf.int=TRUE gives (Wald) CIs
# adding conf.method="profile" (along with conf.int=TRUE) gives likelihood profile CIs
# You can also get confidence intervals by parametric bootstrap (method="boot"), which is considerably slower but more accurate in some circumstances.

# A data frame of values at which to estimate probabilities:
values <- comments_coded %>% 
  tidyr::expand(`log(coalition_comments)` = seq(0:10),
                `log(coalition_size)` = seq(0:1),
                Position,
                coalition = c("Aclu", "American Petroleum Institute", "Defenders Of Wildlife"),
                president)

broom.mixed::augment(m_me, 
                     type.predict = "response",
                     newdata = values,
                     se_fit = TRUE) %>% 
  #filter(`log(coalition_size)`==0) %>% 
  ggplot() + 
  aes(x = `log(coalition_comments)`, y = .fitted,) +
  geom_point() +
        facet_grid(Position ~ president)
```


