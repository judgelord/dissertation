---
title: "Policy Influence: Do Public Pressure Campaigns Influence Bureaucratic Policymaking?"
subtitle: "Appendix and Replication Code" 
author: "Devin Judge-Lord"
bibliography: '`r here::here("assets/dissertation.bib")`'
# biblio-style: apalike
biblio-style: '`r here::here("assets/apsr.bst")`'
link-citations: yes
citecolor: black
output:
    bookdown::html_document2:
      highlight: zenburn
      toc: true
      toc_float: true
      code_folding: hide
    # pdf_document:
    #   toc: true
    #   keep_tex: true
editor_options: 
  chunk_output_type: console
knit: (function(input, ...) {
    rmarkdown::render(
      input,
      output_file = paste0(
        xfun::sans_ext(input), '.html'
      ),
      envir = globalenv()
    )
  })
---

```{r global.options, include=FALSE}
source(here::here("code", "setup.R"))
library(modelsummary)

# overide defaults
knitr::opts_chunk$set(echo = TRUE, 
                      cache = FALSE,
                      fig.path='../figs/')
```

# Data

Replication data are available in SQL and Rdata at
<https://github.com/judgelord/rulemaking>

```{r data}
load(here::here("data", "rules_metadata.Rdata"))

# alternatively 
#rules <- dbGetQuery(con, "SELECT * FROM rules")

#FIXME REPLACE WITH date 
d <- rules %>% mutate(year = str_sub(posted_date, 1,4) %>% as.numeric()) %>%
  filter(year > 2004, year < 2021, document_type %in% c("Proposed Rule", "Rule"))

load(here::here("data", "comments_min.Rdata"))

# hand coded 
load(here::here("data", "coalitions_coded.Rdata"))
load(here::here("data", "comments_coded.Rdata"))
# load(here::here("data", "mass_coded.Rdata"))

# common names 
comments_coded %<>% 
  mutate(coalition = coalition_comment,
         agency = str_remove(docket_id, "-.*"))

# common names 
coalitions_coded %<>% 
  mutate(coalition = coalition_comment,
         comments = coalition_comments,
         Comments = Coalition_comments,
         agency = str_remove(docket_id, "-.*"))

# coalitions_coded %<>% mutate(across(whereis.character, str_to_title)

# TODO merge in mass comments that were not hand-coded 
```

These data currently include `r unique(rules$docket_id) %>% length()`
dockets,
`r rules %>% filter(docket_type == "Rulemaking") %>% distinct(docket_id) %>% nrow()`
rulemaking dockets from `r min(rules$posted_date, na.rm = T) %>% str_remove(",")` to
`r max(rules$posted_date, na.rm = T) %>% str_remove(",")`. These dockets received
approximately `r sum(rules$number_of_comments_received, na.rm = T)`
comments.

This analysis relies of rulemaking dockets from 2005 through 2020. These 
`r d %>% filter(docket_type == "Rulemaking") %>% distinct(docket_id) %>% nrow()`
rulemaking dockets received
`r d %>% filter(docket_type == "Rulemaking") %>% pull(number_of_comments_received) %>% sum(na.rm = T)`
comments.

---

## Comments from legislators

One mechanism by which campaigns may influence policy is by mobilizing members of Congress. Thus, I identify comments submitted by members of Congress and count the number of legislators in each lobbying coalition. 

```{r congress, fig.cap = "Number of Letters from Members of Congress Received During Rulemaking per Year", out.width = "100%", fig.height=6}
load(here::here("data", "comments_congress.Rdata"))

comments_congress$Year %<>% as.numeric()

breaks <- seq(2000, 2020,by = 2)

comments_congress %>% 
  as_tibble() %>%
  filter(Year %>% as.numeric() > 2000,
         Year %>% as.numeric() < 2021) %>% 
  add_count(agency, name = "agency_n") %>%
  filter(agency_n > 88) %>% 
  count(Year, Chamber, agency, sort = TRUE) %>%
  ggplot() +
  aes(x = Year, y = n, fill = Chamber) + 
  geom_col(position = "stack") + 
  facet_wrap("agency", scales = "free") + 
  labs(x = "" ,
       y = "Number of Rulemaking Comments from Members of Congress") + 
  scale_x_continuous(breaks = breaks) + 
  theme(axis.text.x = element_text(angle = 90),
        axis.ticks.x = element_blank(),
        panel.grid.major.x = element_blank())

# table 
# elected comments by type
comments_coded %>% 
  filter(comment_type == "elected") %>%  
  mutate(org_type = str_remove(org_type, "-.*|;.*| .*")) %>%
  count(org_type,  sort =T) %>% 
  rename(elected_type = org_type) %>%
  kablebox()
```

## Clustering with text reuse

My theoretical approach requires that I *attribute* form letter comments to the organizations, campaigns, and broader coalitions that mobilized them. To do so, I identify comments that share text. I find that a 10-word phrase repeated across more than a few comments is always either text copied from the proposed policy or a form letter provided by a campaign. Thus, for the text of each comment, I first remove all 10-word phrases that appear in the proposed rule (including the preamble and call for comments). Then, I identify all comments that share ten-word phrases with 99 or more other comments. I collapse these form letter comments to one representative sample for hand-coding. 

For each comment on a rulemaking docket^[Where a new presidential administration used the same docket number to solicit comments on a proposed rule that a previous administration used, I count these as separate rulemaking dockets. I do so because the second policy is usually reversing or going in the opposite direction as the policy on which the previous administration solicited comments. The same organizations often comment but with the opposition positions. Support becomes opposition and vice versa.], I identify the percent of words it shares with other comments using a 10-word (or
"10-gram") moving window function, looping over each
possible pair of texts to identify matches.^[For more about n-gram window functions and comparisons with related partial matching methods such as the Smith-Waterman algorithm, see @Casas2017 and @Judge-Lord2017.]
When actors sign onto the same comment, it is clear that they are
lobbying together. However, various businesses, advocacy groups, and
citizens often comment separately, even when they are aligned. Text-reuse (using the same ten-word phrases) captures this alignment. 

Figure \@ref(fig:percent-match) shows the percent of shared text for a sample of 50 comments on the Consumer Financial Protection Bureau's 2016 Rule regulating Payday Loans. Comments are arranged by the document identifier assigned by regulations.gov on both axes. 
The black on the diagonal indicates that each document has a perfect overlap with itself. Black squares off the diagonal indicate additional pairs of identical documents. For example, 100% of the words from Comment 95976 are part of some tengram that also appears in 95977 because the exact same comment was uploaded twice. 
The cluster of grey tiles indicates a coalition of commenters using some identical text.
Comments [91130](https://www.regulations.gov/document?D=CFPB-2016-0025-91130) through [91156](https://www.regulations.gov/document?D=CFPB-2016-0025-91154) are all partial or exact matches. All are part of a mass comment campaign by Access Financial. The percent of the identical text is lower than many mass-comment campaigns because these are hand-written comments, but the n-gram method still picks up overlap in the OCRed text in the header and footer. Tengrams that appear in 100 or more comments indicate a mass comment campaign. Some agencies use similar "de-duping" software [CITE] and only provide a representative sample comment. In these cases, my linking method assumes that the example comment is representative, and I link these comments to others based on the text of the sample comment provided.

```{r percent-match, fig.show = "hold", out.width = "100%", fig.cap="Percent of Matching Text in a Sample of Public Comments"}

knitr::include_graphics(here::here("Figs/comment_percent_match_plot-1.png")  )
```




## Hand-coded sample

To estimate the influence of public comments on policy, I code almost all* comments on a random sample of rules, recording the type of organization, the lobbying coalition to which each belongs, the type of coalition (primarily public or private interests), their policy demands, and the extent to which the change between draft and final rule aligned with their demands. This level of alignment between policy asks and policy outcomes is my measure of lobbying success. It does not identify a causal relationship--true policy influence, but it is state of the art with these kinds of observational data (see @Yackee2006JOP). 

*On each selected rule, I code all comments submitted as file attachments or emails, but only some comments typed in a text box. I include comments typed in a text box if they share text with other comments (see above). This includes nearly all comments on most rules, excluding entirely unique text-box content, which is marginal both qualitatively and quantitatively. For comments sharing text, I code one sample document for all versions of the form letter. 

My approach to measuring lobbying success starts with policy demands raised in comments. I code the general regulatory/deregulatory direction of the policy change, but the dimensions of conflict on which I judge lobbying success are those identified by commenters. They do not emerge from a reading of the policy or not any a priori concept. Instead, I read the change between draft and policy with an eye for alignment with commenters' requests (including requests that specific parts of the draft policy do not change.)


My approach of identifying the dimensions of the conflict by comments has benefits and downsides. Compared to other potential measures of success, it is more likely to focus on things that commenters care about. For example, one could measure success by the number of times a comment is mentioned in the agency's response to comments. However, this may capture strategic responsiveness by agencies choosing to discuss some issues more than others. It also counts explicit rejections toward the measure of responsiveness. One could also measure success by focusing on a-priory potential aspects of the policy. @Balla2020 count five factors: (1) the number of regulated entities, (2) number of activities or substances being regulated, (3) the level of pollution standards, (4) the compliance and effective deadlines of the regulation, and (5) the monitoring and reporting requirements. Each takes one value (increasing or decreasing), and each is weighted equally in the analysis. In contrast, starting with comments allows commenters to highlight the issues they care most about.




### By organization


Organization-level data sample:
```{r}
library(tidyverse)
comments_coded %>% 
  dplyr::select(document_id, comment_type, comments, starts_with(c("org_", "coalition")), -org_name_short) %>% 
  group_by(coalition_comment) %>% 
  slice(n = 2) %>%
  kablebox()
```

---

Summary counts:

```{r}
# org comments by type 
comments_coded %>% filter(comment_type == "org") %>%  
  mutate(org_type = str_remove(org_type, ";.*")) %>%
  count(org_type, sort =T) %>% 
  kablebox()

# org comments by sub-type
comments_coded %>% filter(comment_type == "org") %>%  
  filter(str_detect(org_type, ";")) %>% 
  mutate(org_type_detailed = org_type) %>%
  count(org_type_detailed, sort =T) %>% 
  kablebox()
```


### By coalition

Coalition-level data sample:

```{r data-coded, cache = FALSE}
# common names 
coalitions_coded %<>% 
  mutate(coalition = coalition_comment,
         comments = coalition_comments,
         agency = str_remove(docket_id, "-.*"))

coalitions_coded %>% ungroup() %>% group_by(docket_id) %>% 
  slice_max(coalition_comments, n = 2) %>%
  dplyr::select(docket_id, starts_with("coalition")) %>% 
  distinct() %>% 
  kablebox()
```

Histograms of coalition variables

```{r hist-coalitions, fig.width=2, fig.height=2,  out.width = "30%", fig.cap="Hand-coded Data by Coalition", cache=FALSE}
d <- coalitions_coded 

ggplot(d, aes(x = coalition_success)) + 
  geom_histogram() + 
  labs(x = "Coalition Success")

ggplot(d, aes(x = coalition_size)) + 
  geom_histogram() + 
  labs(x = "Coalition size")
```

---

Number of comments 

```{r hist-comments,  fig.width=3, fig.height=2, out.width = "49%", fig.cap="Number of Comments Linked to Hand-Coded Coalitions", cache=FALSE}
#TODO
#ggplot(d, aes( x= comment_length)) + geom_histogram()+ labs(x = "% (Comment length/proposed rule length)*100")
ggplot(d, aes( x= log(comments))) + 
  geom_histogram() + 
  labs(x = "Log(comments)")
```

---

Coalitions by type (public interest vs. private interest)

```{r hist-coalitions-type}
ggplot(d %>% drop_na(coalition_type)) + 

    aes(x = as.numeric(coalition_business)) + 
  geom_histogram(stat = "count") + 
  labs(x = "Businesses per coalition",
       title = "Number of Businesses by Coalition Type") + 
  facet_wrap("coalition_type")#, scales = "free_x")

ggplot(coalitions_coded %>% filter(!is.na(coalition_type)), aes(x = Coalition_size)) + 
  geom_histogram(stat = "count")+ 
  labs(x = "Coalition Size",
       title = "Coalition Size by Coalition Type") +
  facet_wrap("coalition_type", scales = "free_x")

ggplot(coalitions_coded %>% filter(!is.na(coalition_type)), aes(x = Comments)) + 
  geom_histogram(stat = "count")+ 
  labs(x = "Total Number of Comments",
       title = "Number of Comments by Coalition Type") +
  facet_wrap("coalition_type", scales = "free_x")
```

---

```{r coded-coalition-congress, include=FALSE, fig.cap= "Lobbying Success by Number of Supportive Comments"}
#FIXME include when I have more MOCs
coalitions_coded %>% 
  drop_na(coalition_type, Coalition_Position) %>% 
  distinct(coalition_comment, coalition_type, coalition_size, coalition_congress, comments, agency, Coalition_Position) %>% 
  ungroup() %>%
  ggplot() +
  aes(y = coalition_congress, x = log(comments), color = coalition_type) +
  geom_jitter(aes(size = coalition_size), alpha = .5) +
  geom_smooth(se = FALSE, method = "lm")+ 
  facet_grid(Coalition_Position ~ .) 
```


#### Number of supportive comments

```{r coded-coalition-success-comments, fig.cap= "Lobbying Success by Number of Supportive Comments"}
coalitions_coded %>% 
  drop_na(coalition_type, Coalition_Position) %>% 
  distinct(coalition_comment, coalition_type, coalition_size, coalition_success, comments, agency, Coalition_Position) %>% 
  ungroup() %>%
  ggplot() +
  aes(y = coalition_success, x = log(comments), color = coalition_type) +
  geom_jitter(aes(size = coalition_size), alpha = .5) +
  geom_smooth(se = FALSE, method = "lm")+ 
  facet_grid(Coalition_Position ~ .)

coalitions_coded %>% 
  drop_na(coalition_type, Coalition_Position) %>% 
  distinct(coalition_comment, coalition_type, coalition_size, coalition_success, comments, agency, president, Coalition_Position) %>% 
  mutate(comments = comments) %>% 
  ungroup() %>%
  ggplot() +
  aes(y = coalition_success, x = log(comments), color = coalition_type) +
  geom_jitter(aes(size = coalition_size), alpha = .5) +
  geom_smooth(se = FALSE, method = "lm") + 
  #facet_wrap("president")  + 
  facet_grid(Coalition_Position ~ president)
```

#### Coalition Size

(number of supportive organizations)

```{r coded-coalition-success-size, fig.cap= "Lobbying Success by Number of Supportive Comments"}
coalitions_coded %>% 
  drop_na(coalition_type, Coalition_Position) %>% 
  distinct(coalition_comment, coalition_type, coalition_size, coalition_success, comments, agency, president, Coalition_Position) %>% 
  ungroup() %>%
  ggplot() +
  aes(y = coalition_success, x = coalition_size, color = coalition_type) +
  geom_jitter(aes(size = comments ), alpha = .5) +
  geom_smooth(se = FALSE, method = "lm") + 
  facet_grid(Coalition_Position ~ .)+ 
  scale_size_continuous(labels = comma)

coalitions_coded %>% 
  drop_na(coalition_type, Coalition_Position) %>% 
  distinct(coalition_comment, coalition_type, coalition_size, coalition_success, comments, agency, president, Coalition_Position) %>% 
  ungroup() %>%
  ggplot() +
  aes(y = coalition_success, x = coalition_size, color = coalition_type) +
  geom_jitter(aes(size = comments ), alpha = .5) +
  geom_smooth(se = FALSE, method = "lm") + 
  #facet_wrap("president") + 
  facet_grid(Coalition_Position ~ president)+ 
  scale_size_continuous(labels = comma)
```



## Machine-coded Data

> IN PROGRESS

**Dependent variable:** *The percent change in policy text*...

**Explanatory variables:** The *total number of comments*...

# Descriptives

```{hypothesis, meditated, echo = TRUE}
Most people engage in national policy processes as a result of organized public pressure campaigns.
```

Hand-coded sample [in progress]

```{r}
comments_coded %>% 
  # split out mass comments submitted with org comments
  mutate(comment_type = ifelse(comment_type == "org" & comments > 99,
         "org;mass", 
         comment_type) %>% 
  str_split(";")) %>% 
  unnest(comment_type) %>% 
  mutate(comments = ifelse(comment_type == "org",
                           1, 
                           comments)) %>% 
  group_by(comment_type) %>% 
  tally(comments) %>% 
  kablebox()
```

Full data [in progress]

```{r}
# massive undercount of mass
#TODO include new, further collapsed data
comments_min %>% 
  mutate(mass = number_of_comments_received > 99) %>% 
  group_by(mass) %>% 
  tally(number_of_comments_received)%>% 
  kablebox()
```

```{hypothesis, coalitions, echo = TRUE}
Public pressure campaigns are organized by *coalitions* that include groups that engage in sophisticated technical lobbying.
```

>Nearly all mass comments in the hand-coded rules were mobilized by a group that also engaged in sophisticated lobbying.

>Organizations (if any) affilitated with different types of comments in the hand-coded data:

```{r}
comments_coded %>% 
  group_by(docket_id, coalition, coalition_comments, coalition_type) %>% 
  mutate(comment_type = comment_type %>% as.factor()) %>%
  count(comment_type) %>%
  ungroup() %>% 
  drop_na(comment_type) %>% 
  filter(!comment_type %in% c("NA", "coalition", "mass")) %>% 
  pivot_wider(names_from =  comment_type, values_from = n) %>%
  arrange(-coalition_comments) %>% 
  kablebox()
```

```{hypothesis, public, echo = TRUE}
Public interest group coalitions mobilize *more often* than private interest group (e.g., business-led) coalitions.
```

> Yes, but not as much as I expected.

```{hypothesis, public-success, echo = TRUE}
Public interest group coalitions mobilize *more successfully* than private interest group (e.g., business-led) coalitions. 
```

> Yes, by far.

```{hypothesis, resources, echo = TRUE}
Public pressure campaigns targeting national policy are most often run by large national policy advocacy organizations.
```

> Yes.

```{hypothesis, disrupt, echo = TRUE}
If narrow private interest groups (e.g., businesses) launch public pressure campaigns, it is a response to an opposing campaign. 
```

> Yes.

# Models of influence/success

## DV = Comments from members of Congress


```{hypothesis oversight, echo = TRUE}
The scale of public engagement moderates elected officials' engagement in agency rulemaking
engagement.
```


The simplest model of the relationship between congressional attention and public attention would to model the count of legislator letters as a function of features of a rulemaking, including the total number of public comments. The number of letters from members of congress would be a count process, this would be a poisson or negative binomial regression.

In equasion \@ref(eq:oversight1), $y_{j}$ is a count of the number of legislator comments on a proposed rule $j$, $\beta_1$ is the effect of a one unit increase in the logged number of public comments on proposed rule $j$, and $\eta$ is a vector of coefficients on other factors ($X_{j}$) that may lead legislators to comment.

$$
y_{j}= \beta_0 + \beta_1 \text{log(Public comments)}_{j} + \eta X_{j} + \epsilon_{j} (\#eq:oversight1)
$$

---

Alternatively, if we want to control for legislator charateristics that may make them more or less likely to comment on a rule, we can make members of Congress the unit of analysis. The dependent variable is now whether or not a given legislator $i$ commented on proposed rule $j$. The relationship between public engagement and legislator engagement can be modeled by Equation \@ref(eq:oversight2) where $Pr(Comment_{ij})$ is the probability that legislator $i$ comments on a proposed rule $j$, $\beta_1$ is the effect of a one unit increase in the logged number of public comments on proposed rule $j$, and $\eta$ is a vector of coefficients on other factors ($X_{ij}$) that may affect whether a legislator engages.


$$logit(Pr(\text{Legislator comment}_{ij})) = \beta_0 + \beta_1 \text{log(Public comments)}_{ij} + \eta X_{ij} + \epsilon_{ij}
(\#eq:oversight2)$$



---

```{hypothesis beacon, echo = TRUE}
Public pressure campaigns attract
oversight from allies. The more comments supporting a position, the more
likely principals holding that position are to engage.
```

```{hypothesis warning, echo = TRUE}
Public pressure campaigns
reduce oversight from opponents. The more comments opposing a position,
the less likely principals holding that position are to engage.
```

The simplest model of the relationship between congressional attention and public support or opposition to a propopsed rule would to model the net count of legislator letters supporting and opposing the proposed as a function of features of a rulemaking, including the net number of public comments supporting and opposing. As the number of letters from members of congress would be a count process, this would be Poisson or negative binomial regression.

The model is the same as equasion \@ref(eq:oversight1) except that $y_{j}$ is now the *net* number of legislator comments supporting a proposed rule $j$, and $\beta_1$ is now the effect of a one unit increase in the logged *net* number of public comments supporting proposed rule $j$.

---

With a measure of the likely position on each rule (for example, if promulgated by a co-partisan administration), the individual legislator can be the unit of anlysis. The probability that legislator $i$ will comment on rule $j$, given their position $p_{ij}$ on a proposed rule $j$ ($Pr(Comment_{ij}i|p_{ij})$), is modeled in equation \@ref(eq:oversight4). Hypothesis \@ref(hyp:beacon) implies that $\beta_1$ is positive and
Hypothesis \@ref(hyp:warning) implies that $\beta_2$ is negative.


$$logit(Pr(\text{Legislator Comment}_{ij}|p_{ij})) = \beta_0 + \beta_1 \text{Comments supporting } p_{ij} + \beta_2 \text{Comments opposing } p_{ij} + \eta X_{ij} + \epsilon_{ij}
(\#eq:oversight4)$$

---

## DV = Lobbying success

For all three measures of lobbying success, I assess the relationship between lobbying success and mass comments by modeling coalition $i$'s lobbying success in a rulemaking $j$, $y_{ij}$ as a combination of
<!--the relative length of the (lead) organizations comment,--> 
whether the coalition is unopposed, the coalition's size, whether it is a business coalition, and the logged number of mass comments. I estimate these relationships using OLS regression. <!--I also estimate hand-coded lobbying success with beta regression and ordered logit, which is more appropriate but less interpretable. For the automated measures of lobbying success, I estimate beta regression models with the same variables.-->


$Y_{ij} = \boldsymbol{\beta}_1 \textbf{log(Comments)}_{ij} + {\beta}_2\text{Size}_{ij} + {\beta}_3\text{Unopposed}_{ij}  + {\beta}_3\text{Coalition Type}_{ij} + \epsilon_{ij}$

I use two related measures of coalition type. Models 1 and 3 use my classification of coalitions as primarily public or private interests. Models 2 and 4 below use a related measure--the share of coalition members that are buisnesses or trade associations. Models 3 and 4 include interact each measure of the coalition's type with a dummy for president Trump rather than President Obama's administration. Bush-era rules are dropped from these models for simplicity. 


### Challenges for inference{-}

#### Non-independence {-}

##### Organzations lobbying in coalitions {-}

The hand-coded sample includes `r nrow(comments_coded)` hand-coded documents representing `r sum(comments_coded$comments)` comments. However, many of these comments belong coalitions and are thus not independent. When Friends of Earth and the Sierra Club lobbying together on a rule, the success of each depends on the other. Thus, I group comments into coalitions. The hand-coded sample includes `r nrow(coalitions_coded)` "coalitions," `r coalitions_coded %>% filter(coalition_size == 1) %>% nrow()` of which are single organizations (not really coalitions), leaving `r coalitions_coded %>% filter(coalition_size > 1) %>% nrow()` true coalitions of groups lobbing together. 

#### Coalitions lobbying on rules

The fact that several coalitions may lobby on the same rule creates a lesser form of dependence among observations. One coalition's lobbying success is correlated with another coalition's lobbying success to the extent that they are asking for the same or contradicting things. Because we have grouped organizations into coalitions, the causally-related asks (those organizations lobbying *because* another organization is) are largely accounted for. 


# Results

### DV = Coalition success

> Note: these models include coalitions of 1 (organizations lobbying alone), but results are similar if I exclude them, except that coalition size has a much weaker correlated with success. 

> NOTE: At this time, the sample is mostly rules that recieved an unusual number of comments, so these results are based on variation with high-salience rulemakings. 

```{r model-success, cache=FALSE}
m_business <- lm(coalition_success ~ 
          log(comments) + 
          #comment_length + 
          coalition_business +  
          log(coalition_size) + 
          coalition_unopposed, 
        data = coalitions_coded) 

m <- lm(coalition_success ~ 
          log(comments) + 
          #comment_length + 
          coalition_type +  
          log(coalition_size) + 
          coalition_unopposed, 
        data = coalitions_coded) 

m_business_president <- lm(coalition_success ~ 
          log(comments) + 
          #comment_length + 
          coalition_business*president +  
          log(coalition_size) + 
          coalition_unopposed, 
        data = coalitions_coded %>% filter(president != "Bush")) 

m_president <- lm(coalition_success ~ 
          log(comments) + 
          #comment_length + 
          coalition_type*president +  
          log(coalition_size) + 
          coalition_unopposed, 
        data = coalitions_coded %>% filter(president != "Bush")) 

models <- list(m, 
               m_business, 
               m_president,
               m_business_president)

modelsummary(models, stars = TRUE)
```

My preferred model is model 3: 

```{r model-success-plot, cache=FALSE,  fig.width=6, fig.height=2, out.width = "100%", fig.cap= "OLS Model of Coalition Lobbying Sucess with Hand-coded Data"}
# model-success-plot
m_president %>%
  tidy(conf.int = TRUE) %>% 
  filter(term != "(Intercept)") %>% 
  ggplot() + 
  geom_hline(yintercept = 0, color = "grey") + 
  aes(x = term, 
      y = estimate, 
      ymin = conf.low, 
      ymax = conf.high) + 
  geom_pointrange( )  + 
  coord_flip() +
  labs(y = "Lobbying Success", 
       x = "") 
```

<!--
**Excluding** coalitions of 1 (organizations lobbying alone):

```{r model-success-restricted, cache=FALSE}
m_business <- lm(coalition_success ~ 
          log(comments) + 
          #comment_length + 
          coalition_business +  
          log(coalition_size) + 
          coalition_unopposed, 
        data = coalitions_coded %>% filter(coalition_size != 1)) 

m <- lm(coalition_success ~ 
          log(comments) + 
          #comment_length + 
          coalition_type +  
          log(coalition_size) + 
          coalition_unopposed, 
        data = coalitions_coded %>% filter(coalition_size != 1)) 

m_business_president <- lm(coalition_success ~ 
          log(comments) + 
          #comment_length + 
          coalition_business*president +  
          log(coalition_size) + 
          coalition_unopposed, 
        data = coalitions_coded %>% filter(president != "Bush")%>% filter(coalition_size != 1)) 

m_president <- lm(coalition_success ~ 
          log(comments) + 
          #comment_length + 
          coalition_type*president +  
          log(coalition_size) + 
          coalition_unopposed, 
        data = coalitions_coded %>% filter(president != "Bush")%>% filter(coalition_size != 1)) 

models <- list(m, 
               m_business, 
               m_president,
               m_business_president)

modelsummary(models, stars = TRUE)
```


```{r model-success-plot-restricted, cache=FALSE,  fig.width=6, fig.height=2, out.width = "100%", fig.cap= "OLS Model of Coalition Lobbying Sucess with Hand-coded Data"}
# model-success-plot
m_president %>%
  tidy(conf.int = TRUE) %>% 
  filter(term != "(Intercept)") %>% 
  ggplot() + 
  geom_hline(yintercept = 0, color = "grey") + 
  aes(x = term, 
      y = estimate, 
      ymin = conf.low, 
      ymax = conf.high) + 
  geom_pointrange( )  + 
  coord_flip() +
  labs(y = "Lobbying Success", 
       x = "") 
```
-->

#### Modeling Congressional Support as a Mediator of Lobbying Success

To assess congressional support as a mediator in the influence of public pressure campaigns on rulemaking, I estimate the average conditional marginal effect (ACME, conditional on the number of comments from Members of Congress) and average direct effect (ADE) of mass comments using mediation analysis. Model 3 in table \@ref(tab:mediation) replaces the dependent variable (lobbying success) with the mediator variable (the number of supportive members of Congress). Model 1 is the same as Model 1 above. Model 1 is the same, but includes the proposed mediator, the number of supportive comments from members of Congress.

```{r causal-oversight, fig.cap = "The Mediator Model: The Relationship Between Public Pressure and Congressional Oversight"}
#TODO add headers, cut out demands, add political information box, shift principal comments over
#TODO add outcome model
knitr::include_graphics(here::here("figs", "causal-oversight-1.png"))
```

---

##### Mediator model \@ref(eq:mediator):

$$
\text{Congressional support}_{ij} = \beta_0 + \beta_1 log(\text{Comments}_{ij}) + \beta_{2-n} X_{ij} + \epsilon_{ij} (\#eq:mediator)
$$

```{r model-oversight, cache=FALSE}
# model predicting mediator
model.m <- glm(coalition_congress ~  log(comments) + #comment_length +
                coalition_type +  log(coalition_size) + coalition_unopposed,
               family = "poisson",
               data = coalitions_coded %>% filter(!is.na(coalition_success))) 


mediator <- list("Members of Congress in Coalition" = model.m)

modelsummary(mediator, stars = TRUE)
```


```{r model-oversight-plot, cache=FALSE,  fig.width=6, fig.height=2, out.width = "100%", fig.cap= "OLS Model of the Numeber of Members of Congress Per Coalition with Hand-coded Data"}
model.m %>%
  tidy(conf.int = TRUE) %>% 
  filter(term != "(Intercept)") %>% 
  ggplot() + 
  geom_hline(yintercept = 0, color = "grey") + 
  aes(x = term, 
      y = estimate, 
      ymin = conf.low, 
      ymax = conf.high) + 
  geom_pointrange( )  + 
  coord_flip() +
  labs(y = "Number of Legislator Comments", 
       x = "") 
```


---

##### Outcome model 


```{r causal-oversight-2, fig.cap = "Integrating Public Pressure and Congressional Oversight into a Model of Lobbying in Bureaucratic Policymaking"}
#TODO label "Public Pressure" and "Oversight" portions. 
knitr::include_graphics(here::here("figs", "causal-oversight-2.png"))
```



($y_{ij} = \text{Lobbying\ success}_{ij}$) \@ref(eq:outcome):


$$
y_{ij} = \beta_0 + \beta_1 log(\text{Comments)_{ij}) + \beta_2 congressional\ support_{ij} + \beta_{3-n} X_{ij} + \epsilon_{ij} 
(\#eq:outcome)
$$



```{r mediation, cache=FALSE}
# model predicting DV
model.y <- lm(coalition_success ~ log(comments) + 
                coalition_congress + #comment_length + 
                coalition_type +  
                log(coalition_size) + 
                coalition_unopposed, 
              data = coalitions_coded) 

# Mediation 
med.cont <- mediate(model.m, model.y, sims=1000, treat = "log(comments)", mediator = "coalition_congress")

summary(med.cont)


models <- list(
  "1" = m,
  "2" = model.y,
  "3"  =  model.m
)

rows <- tibble(
  term = c("Dependent Variable"),
  `1` = c("Lobbying Success"), 
  `2` =c("Lobbying Success"), 
  `3`  = c("Members of Congress in Coalition")
)

# #broom::tidy(m_PR)
# cm = c("ej_commentTRUE" = "EJ Comment",
#        "log(comments + 1)" = "Log(Comments+1)",
#        "ej_comments_unique" = "Unique EJ Comments",
#        "ej_commentTRUE:log(comments + 1)" = "EJ Comment*Log(Comments+1)")

attr(rows, 'position') <- c(0)

# paper table
modelsummary::modelsummary( models,
                            title = "Lobbying Success and Congressional Support",
                            stars = TRUE,
                            #coef_omit = "president.*|agency.*|Intercept",
                            # coef_map = cm,
                          add_rows = rows,
                          notes = "") %>%
  row_spec(row = 1, bold = T) #%>% kable2(file = "mediation")
```

> Mediation analysis will require adding cases where coalitions lobbied unopposed, which we are much more likely to see in the sample of rules without mass comments.



The average effect of the logged number of comments, conditional on letters from members of congress (the ACME) is `r round(med.cont$d.avg, 2)`, with a p value of `r round(med.cont$d0.p, 4)`.

The average direct effect (ADE) of the logged number of comments on lobbying success is `r round(med.cont$z0, 2)`, with a p-value of `r round(med.cont$z0.p, 4)`.

The Total Effect of a one-unit increase in the logged number of comments is `r round(med.cont$tau.coef, 2)`, with a p value of `r round(med.cont$tau.p, 2)`. `r round(med.cont$n0, 2)` of this is mediated through mobilizing congressional attention (p-value = `r round(med.cont$n0.p, 2)`).

### DV = organzation success

While it would not be appropriate to compare the lobbying success of organizations *within* a rulemaking (because many organizations belong to the same coalition), it may be appropriate to compare the lobbying success *within* the same organization *across* rules. This limits the analysis to organizations that lobbying on multiple policies. The key variation of interest is when organizations lobby with a large amount of public support versus when they do not.


There is still a (lesser) problem with the i.i.d. assumption here because two organizations lobbying in a coalition on one rule may mobilize each other to lobby in coalition in a different rule (in my data, lobbying coalitions are at the policy-level, since they differ from policy to policy). 

```{r}
orgs <- comments_coded %>% 
  filter(comment_type == "org") %>% 
  distinct(org_name, docket_id, success, Position, coalition_size, coalition_comments, president) %>% 
  count(org_name, sort = T) %>% 
  filter(n >1, !is.na(org_name)) %>%
  mutate(org_name = org_name %>% str_to_title())

orgs %>% kablebox()
```

`r nrow(orgs)` organizations lobbied on more than one rule in the hand-coded data, some on as many as `r max(orgs$n)` rulemaking dockets. This yields a total of `r sum(orgs$n)` observations of an organization lobbying on a docket that also lobbied on some other docket. 
(Note: this is a undercount due to imperfect standardization of organization names).


At the organization level, the appropriate analysis is a difference-in-difference design. We know the success of each organization when it does and does not participate in a lobbying coalition that mobilizes public pressure (at least each organization that I can use for this analysis). The difference within an organization is now the key variation.  

$Y_{ij} = \boldsymbol{\beta}_1 \textbf{Comments}_{ij} + \gamma_{i} + {\beta}_2\text{Coalition Size}_{ij} + {\beta}_3\text{Support}_{ij}  + {\beta}_4\text{President}_{j} + \epsilon_{ij}$

<!--+ {\beta}_5\text{Coalition Type}_{ij} +{\beta}_6\text{Coalition Type}_{ij}*\text{President}_{j} -->

Where $Y_{it}$ represents the level of success that organization $i$. $\gamma_{ij}$ is a fixed effect for
the organization. This fixed effect accounts for the organization's
characteristics. This difference-in-difference design ensures that
coefficient $\boldsymbol{\beta}_1$ captures variation related to changes
in levels of public pressure, not other factors that may vary
across organizations. <!--The model also accounts for
the different periods for which data were available from each agency.
$\delta_{jt}$ is an agency-year fixed effect, takes into account
agency-level common shocks across commenters in responsiveness to comment.-->



${\beta}_2$ captures the effect of coalition size on lobbying success of organization $i$ on rule $j$. ${\beta}_3$ captures the difference in the success of organization $i$ when they support proposed policy $j$ rather than oppose it. ${President}_{j}$ is a dummy for whether policy $j$ was proposed by President Trump rather then-president Obama's administration.

Assuming that organizations have parallel trends in their level of success given a level of support, $\boldsymbol{\beta}$ represents the average effect of changing levels of public pressure on an organization's lobbying success.

Estimates in the table below show the results of this model. It suggests that the same organization was less effective when it mobilized more comments, more successful when they supported the rule, and less successful under president Trump than President Obama. 

The negative correlation between lobbying success and the number of mass comments is likely due to campaigns "going down fighting"--not trying to influence policy. The fact that organizations are more likely to get the outcome they seek when they already support the rule makes sense because the agency is more likely to be sympathetic to their requests. The fact that the average organization was less likely to see its desired policy changes under President Trump is likely due to asymmetry in mobilizing organizations, with more organizations on the left than the right in this sample of rules. (Note: this may change in the broader sample.)

<!--
Model 2 shows a similar model, adding a fixed effect for the rulemaking docket (i.e., each policy on which an organization comments). Because I consider policies published by different administrations to be distinct, regardless of the docket id number used, the president does not vary across dockets, and it no longer makes sense to include the president dummy. 

This model also shows ....
Because relatively few campaigns mobilize on any given rulemaking docket, there is little variation within dockets.
-->
```{r m-coded-org-success-did}
library(fixest)

m_fe_org = feols(success ~ log(coalition_comments) + coalition_size + Position + president | org_name,
               data = comments_coded %>% 
  filter(comment_type == "org") %>% 
  distinct(org_name, docket_id, success, Position, coalition_size, coalition_comments, president) %>% filter(president != "Bush"))

models <- list("Lobbying Success" = m_fe_org)

modelsummary(models, stars = T)
```

